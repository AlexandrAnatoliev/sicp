;;;; 1.1.6 Условные выражения и предикаты

(defun abs (x)
  "Функция возвращающая модуль числа X"
  (cond ((> x 0) x)         ; ветви (предикат выражение-следствие)
	((= x 0) 0)
	((< x 0) (- x))))

(abs -1)

(defun abs2 (x)
  "Вернет модуль числа X"
  (cond ((< x 0) (- x))     ; (предикат) (следствие)
	 (else x)))         ; (альтернатива)

(abs2 -2)

(defun abs3 (x)
  "Модуль X"
  (if (< x 0)               ; (предикат)
      (- x)                 ; (следствие)
    x))                     ; (альтернатива)

(abs3 -3)

;; Операции логической композиции

(defun fun1 (x)
  "Проверяет входит ли число в диапазон 5 < X < 10"
  (and (> x 5)
       (< x 10)))

(fun1 4)

(defun more (x y)
  "Проверяет условие X >= Y"
  (or (> x y)
      (= x y)))

(more 5 4)

(defun more2 (x y)
  "X >= Y"
  (not (< x y)))

(more 5 4)

;; Упражнение 1.1

10                  ; 10
(+ 5 3 4)           ; 12
(- 9 1)             ; 8
(/ 6 3)             ; 2
(+ (* 2 4) (- 4 6)) ; 6

(setq a 3)          ; 3
(setq b (+ a 1))    ; 4

(+ a b (* a b))     ; 19
(= a b)             ; nil

(if (and (> b a) (< b (* a b)))
    b               
  a)                ; 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))    ; 16

(+ 2 (if (> b a)
	 b
       a))          ; 6

(* (cond ((> a b) a)
	 ((< a b) b)
	 (else -1))
   (+ a 1))         ; 16

;; Упражнение 1.2

(/ (+ 5 4
      (- 3
	 (+ 5
	    (/ 4.0 5))))
   (* 3
      (- 6 -2)
      (- 2 7)))

;; Упражнение 1.3

(defun func-1-2 (num1 num2 num3)
  "Принимает числа NUM1, NUM2, NUM3 и возвращает сумму квадратов двух больших из них"

  (cond ((and (> num1 num2)
	      (> num2 num3))
	 (setq fact1 num1
	       fact2 num2))
	((and (> num1 num2)
	      (> num3 num2))
	 (setq fact1 num1
	       fact2 num3))
	((and (> num2 num1)
	      (> num1 num3))
	 (setq fact1 num2
	       fact2 num1))
	((and (> num2 num1)
	      (> num3 num1))
	 (setq fact1 num2
	       fact2 num3)))

  (+ (* fact1 fact1)
     (* fact2 fact2))
  )

(func-1-2 4 5 3)

;; Упражнение 1.4

(defun a-plus-abs-b (a b)
  "Функция складывает или вычитает значения A и B, в завимости от значения B"
  (funcall (if (> b 0)
	       '+
       '-
     )
	   a
	   b))

(a-plus-abs-b 1 -5)

;; Упражнение 1.5

(defun p ()
  "Бесконечная рекурсия"
  (p))

(p)

(defun test (x y)
  "Тест интерпретатора. Аппликативный порядок вычислений - тест уйдет в рекурсию. Нормальный - выведет 0"
  (if (= x 0)
      0
    y))

(test 0 1)
(test 0 (p))
